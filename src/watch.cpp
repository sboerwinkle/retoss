// Based on code generated by ChatGPT.

#include <errno.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/inotify.h>
#include <unistd.h>

#include "main.h"

#include "watch.h"
#include "watch_gfx.h"

int watch_fd = -1;

std::atomic<char> texReloadFlag = 0;
char texReloadPath[WATCH_PATH_LEN];

static int watchDesc_dl, watchDesc_gfx;

#define BUF_LEN (sizeof(struct inotify_event) + NAME_MAX + 1)
// According to ChatGPT, this alignment stuff is a performance benefit on x86 architectures.
// On other architectures, it may be *mandatory*, as misaligned accesses are much worse there.
// This really isn't performance-critical code, and I doubt the rest of this project is
// portable to other architectures anyway.
// However, I'm still leaving it in for now since it's neat and I learned something.
static char buf[BUF_LEN] __attribute__((aligned(__alignof__(struct inotify_event))));

void watch_read() {
	ssize_t len = read(watch_fd, buf, sizeof(buf));

	if (len == -1) {
		if (errno == EINTR) {
			// We know there's something to read here, but it's still possible we get
			// EINTR from some signal. For now we just leave and let our `poll` loop
			// call us again.
			return;
		}
		// Other error, something's up??
		perror("watch read");
		return;
	}

	struct inotify_event *ev;
	for (
		char *ptr = buf;
		ptr < buf + len;
		ptr += sizeof(struct inotify_event) + ev->len
	) {
		ev = (struct inotify_event *)ptr;

		if (
			!(ev->mask & IN_CLOSE_WRITE)
			|| !ev->len
		) {
			// Not a case we care about (not IN_CLOSE_WRITE),
			// or no data (which shouldn't happen?)
			continue;
		}

		// Only one option right now, but we could add others!
		if (ev->wd == watchDesc_gfx) {
			// Try to let gfx thread know.

			// We're using std::atomic here not not for the actual atomic behavior
			// (even up to int32_t would be automatically atomic on platforms I care about,
			//  so long as it's aligned),
			// but to enforce constraints about the order certain updates are seen by other threads.
			//
			// For instance, the `release` at the end of this section makes sure
			// we don't set `texReloadFlag` before `texReloadPath` is fully written.
			// I'm not sure if we need the `acquire` end here,
			// but I'm 95% certain we do need both ends on the reading side.
			//
			// Of course, I could also use a slightly overengineered tool like a mutex/semaphore
			// and get more readable code, but what about the negligible performance boost I get!
			if (texReloadFlag.load(std::memory_order::acquire)) {
				// Gfx thread still hasn't processed the last one. We just drop this one.
				printf("Missed change for watched file '%s' (gfx)\n", ev->name);
			} else if (ev->len > WATCH_PATH_LEN) {
				// Note that `ev->len` can be longer than `strlen(ev->name)+1`,
				// because multiple null bytes can be included at the end to
				// pad out the structure for memory aligment reasons. This shouldn't
				// be too many though, so probably the path is still pretty dang long.
				printf("Watched file path too long (gfx): '%s'\n", ev->name);
			} else {
				printf("Saw update for '%s'\n", ev->name);
				memcpy(texReloadPath, ev->name, ev->len);
				texReloadFlag.store(1, std::memory_order::release);
			}
		}
	}
}

void watch_init() {
	watch_fd = inotify_init();
	if (watch_fd == -1) {
		perror("inotify_init");
		exit(1);
	}

	/* This will probably be "src" or something, IDK yet where exactly I'm going to watch!
	watchDesc_dl = inotify_add_watch(watch_fd, "../dl_srm", IN_CLOSE_WRITE);
	if (watchDesc_dl == -1) {
		perror("inotify_add_watch for dl");
		close(watch_fd);
		exit(1);
	}
	*/

	watchDesc_gfx = inotify_add_watch(watch_fd, "assets", IN_CLOSE_WRITE);
	if (watchDesc_gfx == -1) {
		perror("inotify_add_watch for gfx");
		close(watch_fd);
		exit(1);
	}

}

void watch_destroy() {
	if (close(watch_fd)) {
		perror("watch close");
	}
}
