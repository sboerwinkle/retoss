// Based on code generated by ChatGPT.

#include <errno.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/inotify.h>
#include <unistd.h>

#include "main.h"

#include "watch.h"
#include "watch_flags.h"

int watch_fd = -1;

// Todo "watch_" prefix on these vars would be nice.
std::atomic<char> texReloadFlag = 0;
char texReloadPath[WATCH_PATH_LEN];

std::atomic<char> watch_dlFlag = 0;
char watch_dlPath[WATCH_PATH_LEN];

static int watchDesc_dl, watchDesc_gfx;

#define BUF_LEN (sizeof(struct inotify_event) + NAME_MAX + 1)
// According to ChatGPT, this alignment stuff is a performance benefit on x86 architectures.
// On other architectures, it may be *mandatory*, as misaligned accesses are much worse there.
// This really isn't performance-critical code, and I doubt the rest of this project is
// portable to other architectures anyway.
// However, I'm still leaving it in for now since it's neat and I learned something.
static char buf[BUF_LEN] __attribute__((aligned(__alignof__(struct inotify_event))));

void watch_read() {
	ssize_t len = read(watch_fd, buf, sizeof(buf));

	if (len == -1) {
		if (errno == EINTR) {
			// We know there's something to read here, but it's still possible we get
			// EINTR from some signal. For now we just leave and let our `poll` loop
			// call us again.
			return;
		}
		// Other error, something's up??
		perror("watch read");
		return;
	}

	struct inotify_event *ev;
	for (
		char *ptr = buf;
		ptr < buf + len;
		ptr += sizeof(struct inotify_event) + ev->len
	) {
		ev = (struct inotify_event *)ptr;

		if (
			!(ev->mask & IN_CLOSE_WRITE)
			|| !ev->len
		) {
			// Not a case we care about (not IN_CLOSE_WRITE),
			// or no data (which shouldn't happen?)
			continue;
		}

		if (ev->len > WATCH_PATH_LEN) {
			// Note that `ev->len` can be longer than `strlen(ev->name)+1`,
			// because multiple null bytes can be included at the end to
			// pad out the structure for memory aligment reasons. This shouldn't
			// be too many though, so probably the path is still pretty dang long.
			printf("Watched file path too long (wd %d): '%s'\n", ev->wd, ev->name);
			continue;
		}

		// Only one option right now, but we could add others!
		if (ev->wd == watchDesc_gfx) {
			// Try to let gfx thread know.

			// We're using std::atomic here not not for the actual atomic behavior
			// (even up to int32_t would be automatically atomic on platforms I care about,
			//  so long as it's aligned),
			// but to enforce constraints about the order certain updates are seen by other threads.
			//
			// For instance, the `release` at the end of this section makes sure
			// we don't set `texReloadFlag` before `texReloadPath` is fully written.
			// I'm not sure if we need the `acquire` end here,
			// but I'm 95% certain we do need both ends on the reading side.
			//
			// Of course, I could also use a slightly overengineered tool like a mutex/semaphore
			// and get more readable code, but what about the negligible performance boost I get!
			if (texReloadFlag.load(std::memory_order::acquire)) {
				// Gfx thread still hasn't processed the last one. We just drop this one.
				printf("Missed change for watched file '%s' (gfx)\n", ev->name);
			} else {
				printf("Saw update for '%s'\n", ev->name);
				memcpy(texReloadPath, ev->name, ev->len);
				texReloadFlag.store(1, std::memory_order::release);
			}
		} else if (ev->wd == watchDesc_dl) {
			// For DL stuff we only care about *.so files
			int sl = strlen(ev->name);
			if (sl < 3 || strcmp(".so", ev->name+sl-3)) {
				continue;
			}
			// If the write is to some '.so' file,
			// we want to open it, pick out a particular function (fixed, for now),
			// run said function, and close the DL handle.
			// However, later on we might be doing more interesting things,
			// including keeping a few different DL handles open at a time.
			// I guess the sensible thing to do would be to have a similar setup to gfx for now,
			// and the game thread (I guess) can deal with whatever logic.
			if (watch_dlFlag.load(std::memory_order::acquire)) {
				printf("Missed change for watched file '%s' (dl)\n", ev->name);
			} else {
				printf("Saw update for '%s' (dl)\n", ev->name);
				memcpy(watch_dlPath, ev->name, ev->len);
				watch_dlFlag.store(1, std::memory_order::release);
			}
		}
	}
}

void watch_init() {
	watch_fd = inotify_init();
	if (watch_fd == -1) {
		perror("inotify_init");
		exit(1);
	}

	/* This will probably be "src" or something, IDK yet where exactly I'm going to watch!
	watchDesc_dl = inotify_add_watch(watch_fd, "../dl_srm", IN_CLOSE_WRITE);
	if (watchDesc_dl == -1) {
		perror("inotify_add_watch for dl");
		close(watch_fd);
		exit(1);
	}
	*/

	watchDesc_gfx = inotify_add_watch(watch_fd, "assets", IN_CLOSE_WRITE);
	if (watchDesc_gfx == -1) {
		perror("inotify_add_watch for gfx");
		close(watch_fd);
		exit(1);
	}

	watchDesc_dl = inotify_add_watch(watch_fd, "src/dl_tmp", IN_CLOSE_WRITE);
	if (watchDesc_dl == -1) {
		if (errno == ENOENT) {
			puts("Couldn't find dl folder, so not doing that very optional thing");
		} else {
			perror("inotify_add_watch for dl");
			close(watch_fd);
			exit(1);
		}
	}
}

void watch_destroy() {
	if (close(watch_fd)) {
		perror("watch close");
	}
}
