
. mouse capture
. better baking
. value dragging

. gp (incl basic name generation for now, and gp selection from code)
	. Basic name gen
	. /gp command
. rotations

. /gp works maybe?

. raytrace selection
	Have some of this thought out in collision.cpp,
	but still needs a bit more to be nice.
. Show group name onscreen
. crosshair

. Oh gods collision will need to be re-done :(

- /rda (round all)
- Segfault loading save file. Maybe just an outdated file?? idk.
- Bug where mottling disappears below scale 1000
- Bug where gestures aren't properly mapped for some rotated things (see the arch in "rubble")
jump intent via mouse (shelved for now)
	If I don't allow air adjustments (which I'm kind of enjoying not doing),
	then cam angle should somehow convey jump itent.
	I'm not sure about wall-jumps,
	but for ground jumps I'm thinking something like:
		Horizontal means just enough force to get traction necessary for maximum speed this frame
		Vertical means full jump force, desired speed is zero'd (or maybe just don't apply traction?)
		45deg (up or down?) means going for distance, so max jump and max traction
		Are ability to apply jump and traction independent?
. Movement is so god-awful lol
- dl: re-frame operation for positions
	Pos vars always store their "on paper" value, and their absolute value
	Then we can set a flag and do a re-load, and they'll update their "on paper" value to maintain absolute value
	Doesn't need to be perfect,
		but I do want to consider a "round away from zero" mode for rotation applications,
		which I think will be helpful for this.
- Parameterized arch
- editing still feels rough
	- I miss my "copy", even if it's just for one obj
	I also keep looking to see if things touch, which feels horrible and bad.
Map design still too open?
	Being fair, I'd hesitate to call anything I've done so far "map design".
	Still, I need a proper building (2 rooms, a la UrT) at some point
		Maybe this waits until we resolve cam positioning (by drawing the player, discussed below)
. Player rendered w/ stippling!
- Cam restrictions
	Cast 4 rays backwards, corresponding to the corners of the "too close to camera" volume.
		Will have to be sure whatever casting mechanic we use is thread-safe,
		and notate methods accordingly so I don't break that in the future.
		Graphics thread is responsible for not stepping on game thread!
	Then, if any of those hits within the appropriate distance,
	set camera distance accordingly.
		Camera sits at the base of the "too close to camera" volume
	This may put the camera actually inside a solid,
	but that's fine so long as they can't peek through a solid.
		An interesting distinction!
	Casting only the corners means we probably won't get some cases right,
	but we handle the important one of "camera is sitting too close to a wall looking parallel".
- capsule player?
	I could just do 2 balls, but I think I could also do a capsule pretty reasonably
		so long as the capsule isn't too long lol
	Idea is that we just change how we compute the test point from the "magic pt" in collision.cpp
	This will get increasingly weird for longer capsules, but for stubby ones it's probably good enough
	Also, have to decide how the collision forceDir is calculated
		I think just "magicPt to capsule center" might work slightly better than "test point capsule normal",
		but honestly they probably both have issues to some degree.
- decor at some pt
	2D sprites I can churn out faster
	they are billboarded
		Some things (like potted plant) should have their vertical axis anchored,
		while others (like crate) would probably do better fully facing the camera.
		Don't need both modes at first, ofc.
	Would feel better if we also gave them a hitbox and let people shoot them,
		though they shouldn't stop bullets since their hitbox will be less obvious.
- Moving complexes
	This is something I've wanted since a while,
		and I've got a rough idea of how it can work with the pieces I've assembled.
	Consider a building on a turntable
	Layout of the building is static (even COW).
		It's stored similarly to velbox boxes, i.e. nested layers
		Idea is we can drop one of these in as an actual velbox box, so radii should be the same,
		but we have to be stricter about child placement.
			(Treat as spheres, not boxes,
			 since they could be realized at any rotation)
	The top level is inserted as a velbox leaf,
	and if game logic is interested in it (player collision, bullet tracing)
	then game logic expands it, trashes the velbox leaf, and inserts new children.
		children position, rotation, etc are calculated at that time.
	Some mechanism by which these children decay if unused for several frames,
		and they're consolidated back to a single velbox leaf at that point.
		This is because "active" children take up nodes in velbox land,
		and also because they need position etc. recalculated each frame.
	Rendering just walks the tree every frame.
		If we want to get cleverer later (i.e. render less when outside?),
		that wouldn't be impacted by these design decisions.

- value-themed commands
	- /v (useful for scale)
	- /v@
	- /v@+ ignores incr, use some other command for edit gestures?
	- /round
	- /incr
